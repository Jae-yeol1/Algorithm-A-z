# 혼공자 한바퀴… (1)

# 자바의 구조 …

![image.png](image.png)

- 자바의 구조를 알아보자!
    
    ---
    
    ---
    
    ![image.png](4b34276d-7501-41f4-b069-6684ccb970d4.png)
    
    ### JDK , JRE , JVM 어떤 개념인지 아시나요?
    
    - 자바를 사용하면서 자바가 어떤식으로 동작하는지 모르면..?
        
        자바의 일단 틀을 아는것이 중요할 것 같다.
        
    
    ### JDK - Java Development Kit 의 약자이다 .
    
    > JDK 는 자바 개발 키트의 약어 , 개발자들이 자바로 개발하는데 사용되는도구
    > 
    
    목수는 독일제 공구 , 음악가는 뛰어난 악기가 필요하듯 .
    
    자바를 개발하는데 있어서 필요한 도구도 버전이 있다 . 자바도 업데이트를 통해 도구를 발전시켜 나가는데 , 
    
    현재 우리가 쓰는 openJDK 17 버전 이전 8 버전부터 람다식 과 , 시간 API ( 자바 초기버전 시간 구현은 지옥같았다..) 등 기능이 생기는 것을 보면 …. 싱기하다 .. 
    
    그리고 자바 21 버전부터 UTF -8이 기본값으로 들어간다고 한다…
    
    ---
    
    ---
    
    ### JRE - Java Runtime Environment
    
    > JRE는 자바 실행 환경의 약어이다 . JVM 과 자바 프로그램을 동작 시킬때 필요하다.
    > 
    
    JRE는 자바 프로그램을 동작 시킬때 필요한 라이브러리 API를 묶어서 배포하는 패키지이다.
    
    JDK 라는 좋은 연장이 있으면 그 연장을 사용할 사람이 필요한데, 자바에선 JRE가 사람의 역할을한다.
    JRE는 JDK를 설치할때 함께 설치된다. 
    **JRE는**  **개발된 프로그램을 실제로 구동시키는 역할**을 한다.
    
    ---
    
    ---
    
    ### JVM- Java Vitrual Mechine
    
    > JVM은 자바 가상머신의 약어이다 . 자바를 돌리는 프로그램이다 .
    > 
    
    JVM은 신기한 역할이 있다. 
    
    C코드를 윈도우 환경에서 짜고 리눅스 환경에서 실행하면 오류가난다… ( C 언어의 종속성 )
    
    우리나라사람도 제주도 사람과 같은언어인 한글을 쓰지만 제주도 사투리를  알아듣기 힘들다..
    살아온 환경이 다르기때문에 말을 이애할 수 없는 것 이다….
    하지만 자바는 JVM 이라는 테크 놀로지로 어느 운영체제 환경이던 서로 알아 먹을 수 있게 ( 각운영 체제에 맞는 전담 통역사를 붙임 ) 
    
    통역을 제공하여 소통을 가능하게 해준다…!
    
    - 설명하자면
    
    소스코드를 받으면 → JDK 컴파일러로 바이트코드로 변환 → JVM 실행 → 통역 ( OS에 맞게 해석 ) 
    

---

---

- 모든 언어의 시작, 변수와 타입  // 기본타입과 참조타입의 차이에 대해 보겠다.
    
    ### 변수
    
    <aside>
    ❓
    
    우리는 살아오면서 변수라는 말을 많이 들어봤을 것이다…
    
    이건 ..변순데…?…등등
    
    수학때문에 익숙할 것이고 … x , y , z 등, 여러가지 값으로 변할 수 있는 수, 
    지금은 데이터를 저장하는 공간으로 사용하고 있다.  
    
    </aside>
    
    ---
    
    ---
    
    ### 변수의 선언
    
    ![image.png](image%201.png)
    
    우리는 변수를 선언하려면 변수의 Type 과 변수 명을 선언한다. 
    
    Int age ;  를 변수라고 할 수 있을까? 
    
    변수에는 값이 들어가야 변수로서 선언이 되었다고 할 수 있다. 
    
    Int age = 25;  이런식으로 말이다 .  
    
    근데 Int age = 25  코드 전체를 ”변수” 라고 할수 있을까?
    
    **int** 는 기본 타입이다 . 기본 타입은  int 외 많이 있다.
    
    **age** 는 25 를 저장하는 **변수명**, 
    
    값 25는 변하지 않는 불변성을 가진 **리터럴**이다..!
    
    변수를 통해 리터럴 값을 저장하고 필요에 따라서 변경도 가능하다. 
    
    **리터럴은 변수와 달리 값을 직접 가리킨다.**
    
    즉 리터럴은 값 자체를 의미하고 변수는 리터럴 값을 저장하는 공간을 의미한다.
    
    <aside>
    🚨
    
    아! 그러면 이런 코드도 다 리터럴이구나 !? 리고 내가 생각 했었다
    
    StringTokenizer tokenizer = new StringTokenizer(data, ",");  
    
    아니다! 
    StringTokenizer 는 타입 tokenizer 는 변수  맞다 . 정확히는 자바에서 만들어둔 클래스,
    
    클래스의 이름이 타입이 되는 것이다.
    
    new StringTokenizer(data, ",");  그러면 당연히 리터럴이겠네?
    
    new 는 연산자로서 메모리 (Heap) 에 새로운 공간을 할당하는 역할을 한다 .
    
    리터럴은 동적으로 공간을 할당 하지 않는다.
    
    StringTokenizer 객체를 초기화하는 “함수” 이다
    
    쉽게 생각하면
    
    String str= “halo” 는 고정된 값 이므로 리터럴.
    
    String str = new String(”halo”) 는 new를통해 메모리에 매핑이 됐으므로 객체 이다.
    
    </aside>
    
    ---
    
    ---
    

---

---

- 쉬워보이지만 막상 쓰려고하면 기억이 안나는 연산자
    
    ### 연산자
    
    <aside>
    ➕
    
    연산자는 수학에서 산술,비교 등 .. 많은 연산자로 배워서 익숙하지만 
    
    프로그래밍 언어에서는 뭔가 미묘하게 달라서 헷갈리니 정의만 빠르게 잡고가겠다.
    
    </aside>
    
    - 연산자에는 여러가지 종류가 있다.
        - 산술 , 대입 , 증감 , 비교 , 논리 , 삼항….
    
    ### 산술 연산자
    
    일반적으로 알고 있는 연산자 제외, 
    
    (  /  ) 나눗셈과 (  %  ) 나머지 구별하기…!
    
    ### 삼항연산자
    
    > 삼항 연산자는 조건 연산자의 한 종류이다, if - then - else 조건문 과 같은 연산을 수행한다.
    > 
    
    ### 예제
    
    ```java
    int a = 50, b = 100 , c = 0;  
    
            // 일반 if-else문 사용
            if(a > b){
    		        int c = 10 ; 
                c = a - b;  // cs,는 -50 
            }else{
                c = b - a;  // 50 
            }  // 정재우님 나이스 스코프
            System.out.println(c); // c = 50
    
            // 삼항 연산자 사용 삼항 연산자안에도 조건을 걸 수 있다
            int d = (a > b) ? a - b : b - a;
            System.out.println(d); // d = 50
            
    	   //기본 형태는   조건         True           false
            result = (condition) **? valueIfTrue : valueIfFalse ;**
    ```
    
    **※ 생각해보기**
    
    for (int count = 0; count < 123;  ++count)
    
    for (int count = 0; count < 123 ; count**++**)
    
    2개의 for 문이 있다 . 증감연산자의 위치에 따라서 값에 차이가 있을까?
    
    - 생각…
        
        다른 연산과 함께할때 , 혹은  다른 연산이 포함 됐다면 …?
        
        for문같이 단독적으로 됐다면.. 차이가 없다..   증감자위치 따라서 생각
        

---

---

- 제어문 … 특히 배열의 친구 조건문
    
    ### 조건문
    
    > 조건문은 조건에 따라 다른 실행문을 실행하는게 목적이다.
    > 
    
    조건문의 종류에는 if 문 , switch 문이 있다. 
    
    ### IF문
    
    if문은 조건식의 결과가 true , false 이냐에 따라 ,실행문이 결정됨..!
    
    If문은 "조건이 맞으면 하고, 아니면 그냥 안함”
    
    편의점에 콜라사러갔는데 콜라가 없으면 그냥 나오는 것임
    
    ![image.png](image%202.png)
    
    ### IF-Else문은
    
    편의점에 콜라를 사러갔는데 “콜라가 있다면 콜라를 사고 , 없으면 사이다를 사는것”
    
    `int money = 500;`
    
    `// if-else를 사용 
    if (money >= 1000) {
    System.out.println("빵을 먹자 냠냠.");
    } else {
    // 조건이 거짓이면 여기가 무조건, 반드시! 실행됨 if 문과 다른점
    System.out.println("껌을 사먹는다.");
    }`
    
    `System.out.println("집에 간다.");
    // 결과: "껌을 사먹는다." , "집에 간다."`
    
    ### switch문
    
    switch 문은 변수의 값에따라 실행문이 결정됨...!
    
    스위치문도 if 문과 마찬가지로 조건 제어문이다 . 하지만 switch 문은 if 처럼 true or false로 블록 내부의 실행문을 실행하는 것이 아님. 
    
    if는 조건식이 2가지 ( T, F ) 밖에 없기 때문에 경우의 수가 많아질 수록 else - if 문을 추가해야해서 코드가 복잡해짐 .  
    
    하지만! switch 문은 변수가 어떤 값을 가지느냐에 따라서 실행문이 결정!
    
    Switch 문을 실행하는데 중요한 키워드가 있는디
    
    - Switch ( 변수 )
    - case 값 :
    - break ; 브레이크 안걸면 아래 조건문까지 다 실행함
    - default : else 와 같은 역할임 , 일치하는 케이스가없다면 실행된다
    
    ```java
    Scanner sc = new Scanner(System.in)
    
    int num = sc.nextInt()
    
    int num = 2; // 사용자가 누른 버튼 번호
    
    switch (num) {
        case 1:
            System.out.println("콜라가 나왔습니다.");
            break; // 자~ 나가자~
    
        case 2:
            System.out.println("사이다가 나왔습니다."); // 여기 실행됨
            break; 
    
        case 3:
            System.out.println("환타가 나왔습니다.");
            break;
    
        default:
            System.out.println("없는 버튼입니다. 동전을 반환합니다.");
    }
    ```
    
    ![image.png](image%203.png)
    
    굳이 굳이 ..  brake 가 고장난 8t truck 마냥 스위치 문을 쓰는 경우도 있다..
    
    ```jsx
    Scanner sc = new Scanner(System.in)
    
    int num = sc.nextInt()
    
    int num = 2; // 사용자가 누른 버튼 번호
    
    switch (num) {
        case 1->
            System.out.println("콜라가 나왔습니다.");
            break;
    
        case 2:
            System.out.println("사이다가 나왔습니다."); // 여기 실행됨
            
    
        case 3:
            System.out.println("환타가 나왔습니다.");
            
    
        default:
            System.out.println("야무지게 먹어야지~");
    }  향상된 스위치문 
    2번을 누르면 사이다 ,환타 등등 나올 수 있게 설정도 가능하다
    ```
    
    ### While 문
    
    > For문은 정해진 횟수만큼 실행 된다면 While문은 조건문이 true이면 계속 실행된다.
    > 
    
    ![image.png](image%204.png)
    
    ### do-while문
    
    > while 문 , do -while 문의 차이를 알아보자
    > 
    
    일반 반복문은 특정 조건이 맞아야 안에 있는 코드가 실행되는데
    
    do-while 문은 반드시 한번은 코드가 실행된다.
    
    굳이 do 안에 코드를 넣는 이유가 뭘까 생각하기  // 다음기회에
    
    ![image.png](image%205.png)
    
    ### 중지는 어떻게 ..?
    
    break 문은 반복문인 for문 , while , do-while 문의 실행을 중지할 때 사용 
    

---

---

- 피드백
    
    ## 피드백
    
    다음주  - 향상된 스위치 문 , 라벨  ,  클래스 /// 객체 인스턴스  매우 비슷하니까 주의하기< 클래스에서 설명 하겠습니다
    
    ### UTF-8 표준
    
    UTF-8은 전자통신에 사용되는 인코딩 표준임
    Unicode Transformation Format – 8-bit 에서 유래 되었다고 합니다~
    
    ### 향상된 스위치문
    

---

---

참조타입 (186) ~ 클래스 (323) 까지

- 참조 타입과 참조 변수
    
    ### 자바의 타입?
    
    > 자바의 타입은 기본타입 ( 정수 , 실수 , 논리 리터럴 ,문자 ) , 
    참조타입 으로 구분된다. 이번시간에는 참조 타입에 대하여 설명 하도록 하겠다!
    > 
    
    ### 번외 ) 기본타입 변수와 참조타입 변수의 연산
    
    - 기본타입 변수의 == , != 연산은 변수의 값이 같은지 , 아닌지를 조사하지만
        - 참조타입 변수의  == , != 연산은 동일한 객체를 참조하는지 , 아닌지 결국 번지 값을 비교하는 것이다
        
        **String strname1 = new String(”홍석”)**
        
        **String strname2 = new String(”홍석”)
        
        내용물이 둘다 홍석이면 같은 해시코드가 찍힐것이다 . 
        그럼 주소 비교하면 참으로 나오겠네???
        
        그렇지 않다 . 
        
        ※  == 연산자는 아묻따 Stack 에 적힌 값으로 비교한다 .** 
        
    
    앞서 보았듯이 기본타입 변수는 값을 변수 안에 저장한다. 
    
    그렇다면 참조 타입은 어떨까?
    배열 , 열거 , 클래스 , 인터페이스 변수는 메모리의 번지를 변수 안에 저장한다…
    번지( 주소 )를 통해 객체를  🚨참조🚨 한다는 뜻에서 참조 타입이라고 함!
    
    ```
    public class exam (
    
        int nUm = 123;  // 기본타입의 변수 변수에 123을 직접 저장하지만. 
    		int 넘 = 321;
    		
        String sTRnaMe = "김홍석"  // String class 를 이용하여서 참조 하였다. 때문에 객체를 참조 하였다.
                                // 때문에 참조 변수라고 부른다.
    
    )
    ```
    
    ![image.png](image%206.png)
    
    int 타입 변수는 값을 가지고 있지만 
    String 객체를 참조한 참조 타입 변수는 메모리의 번지를 변수 안에 저장하고 , 가르키고 있다.
    
    JVM 이 사용하는 메모리 영역이다. 운영체제로 부터 할당 받은 메모리 영역입니다
    
    ![image.png](image%207.png)
    
    ### 메소드(Method)영역
    
    - 메소드 영역은 JVM이 시작될때 가장먼저 생성 된다 .  모든 스레드❓가 공유합니다.
    - 메소드 영역에는 코드에서 사용되는 클래스를 읽습니다
    - 메소드 영역에서 , 
    클래스 별로  정적필드 (Static field) , 상수 필드 ( constant ) , 메소드 코드 , 생성자(Constructor)
     코드를 분류해서 저장함
    
    ### 힙(Heap) 영역
    
    - Heap 영역은 객체와 배열이 생성되는 영역입니다 . 앞서 봤던 new 연산자를 통해 Heap 영역에 메모리 공간 ( 번지를 ) 확보하고 , 그 공간을 생성자(Constructor) 가 초기화를 합니다
    - 여기서 생성된 객체와 배열은 JVM 스택 영역의 변수 , 다른 객체에서 참조함
    - 만일 참조하는 변수가 필드가 없다면  JVM 이 이것을 쓰레기 취급하고 Garbage Collector를 실행시켜서 자동으로 제거를 합니다 .
        
        이게 그동안 말하던 초기화의 개념…? 맞나요
        저는 그냥  new 연산자 사용하면 초기화. 이렇게 알고 있었는데 
         정확하게는  new StringTokenizer  → new 연산자가 힙 영역에 자리 할당 StringTokenizer (생성자) 
        
    
    ### JVM 스택(Stack)영역
    
    - JVM 스택은 **메소드**를 호출 할 때 프레임이 생겼다가 메소드가 끝나면 해당 프레임은 즉시 사라지는 펀쿨섹한 공간입니다.
    add ( int a, int b )  Method가 실행이 된다고 하면 , 
    1. 스택에 프레임 생성
    2.  메소드 안의 본문 a , b, result   같은 지역 변수를 프레임에 저장
    3. 계산이 끝나거나  “ } “  or return
    4. 해당 프레임은 즉시 삭제 , 때문에 지역변수는 메소드 밖에서 못쓰는거임.
    
    라이프사이클 스코프 개념..?
    
    `public void add(int a, int b) {
    int result = a + b;  <- 스택에 지역 변슈둘이 들어가고
    }` ← 프레임 삭제 되는거임 
    
    <aside>
    ❓
    
    객체지향 이론인데, 솔직히 이론만 파는 건 별로 좋아하지 않지만... 그래도 알아두면 정말 유용한 내용인 것 같아요. 
    
    지금 스프링 공부 쪼끔하면서 메모리 영역 구분이 얼마나 중요한지 체감하고 있거든요.
    
    저 같은 경우 NullPointerException 에러 때문에 정말 고생했었어요. 
    이 개념을 제대로 몰랐을 때였죠. 지금 공부하면서 감이 잡히네요
    
    new로 변수에 주소 할당도 안 했는데 참조하려고 하고... 이런 실수들을 반복했었고, 
    보니까 메모리 구조를 이해하면 이런 에러들을 훨씬 쉽게 잡을 수 있더라고요. 
    그래서 여러분께도 공유하고 싶었습니다.
    
    먼저 , 이 JVM 메모리 구조를 이해하려면 스레드 , 프로세스 개념을 알아야 합니다.
    
    ### 스레드
    
    Cpu ?  이름이 익숙하면서 낯선 이 단어를 설명하면 
    
    > **실제로 작업을 수행하는 일꾼**입니다 스타 크래프트 로 따지면 SCV 같은 것 입니다 .
    그렇다고 많으면 좋을까요? 인구 200명 제한있는데 SCV로 인구 수를 다 채워버린다면..?
    > 
    
    자바 실행을 하면 제일먼저 main 스레드가 반드시 하나가 할당이 됩니다. 
    저희 main () 메서드 실행하는 친구입니다.
    
    ### 메소드영역 스레드의 작동
    
    **메소드 영역 공유 이유? :** 스레드가 해야 할 일은 은 모두 같으니까, 설계도는 한 곳에 두고 같이 보자는 것 입니다..!
    
    만일 스레드가 처리해야 할 데이터가 하나인데
    
    스레드 들이 달려가서 너도나도 데이터를 처리하려고 하면 어떻게 될까요?
    
    **메소드 영역**에서는 문제가 없습니다 .  
    ”메소드 영역에는 코드에서 사용되는 클래스를 읽습니다 “ 
    **메소드 영역**에서는 읽기만 하기 때문입니다. 니가 뭘 할 수 있지? 같은 느낌이죠
    스레드를 SCV 라고 생각하고 "커맨드 센터 짓는 법"을 수천마리의 SCV가 읽는다고 해서
    무슨일 생기는게 아니듯이 ,
    
    이제 사고는 후술할 Heap 영역에서 발생합니다. 
    
    ### Heap 영역 스레드의 작동
    
    Heap 영역에서는 데이터 처리가 가능합니다 .
    여러 SCV ( 스레드 ) 가 미네랄이 하나 남은 곳에 우르르 가버린다면 …?
    멈추거나 이상해지겠죠? 
    동기화로 해결 해야합니다
    
    - **동기화 전:** 미네랄 하나에 SCV 10마리가 겹쳐서 서로 캐겠다고 비비적거림. (자원 채취 불가)
    - **동기화 후:** 미네랄에 규칙이 생김.
        - SCV 1번이 캐고 있을 때, 나머지 9마리는 보호막 밖에서 **멍때리며 대기.**
        - 1번 SCV가 다 캐고 나가면, 2번이 입장
        대신 느려집니다 ,
    
    해결책으로 JAVA 에선 강사님이 가끔 쓰시던 **synchronized** ( 동기화 ) 쓰면 해결
    
    1. 메서드에 사용 할 수 있음.
        
        private **synchronized** void method(){}   — 클래스 내부에서만 호출가능하며 여러스레드 침투불가
        
    2. 코드블럭안에서 사용 가능 
        
        ```
        synchronized void display(String s) {
        		for (int i=0; i<5; i++)
        ```
        
        출처:
        
        [https://kadosholy.tistory.com/123](https://kadosholy.tistory.com/123)
        
        [KADOSHoly:티스토리]
        필요한 곳에서만 사용하여 속도 저하 낮춘다고 합니다
        나중에 멀티스레드 배울때 …. 좋은개념이겠죠…? 
        
        ### 스택 영역에서의 스레드 작동
        
        힙 영역에서 모든 스레드가 공유를 하고 있었다면, 
        스택은 다릅니다! 각자 자신만의 스택 메모리를 지급받기 때문입니다
        
        힙 영역은 서로 데이터를 건드려서 동기화 문제가 생기지만 .
        스택 영역은 스레드마다 하나씩 별도로 생성됨 때문에 동기화 할 필요도 없습니다
        
        | **구역** | **비유 (스타)** | **스레드 간 관계** | **위험도** | 동기화 |
        | --- | --- | --- | --- | --- |
        | **Method** | **건물 건설 매뉴얼** | 다 같이 읽기만함 (공유) | **안전** | 없음 |
        | **Heap** | **미네랄 필드** | 서로 캐려고 난리남 (공유) | **위험** | **동기화 
        (줄세우기)** |
        | **Stack** | **SCV 조종석** | 나 혼자 씀 (독점) | **안전** | 없음 |
    
    <aside>
    🤸‍♂️
    
    결국 우리가 동기화 때문에 골머리를 앓는 건 오직 **Heap 영역** 때문이고, 
    Stack 영역(지역 변수)는 개인주의라는 이 차이만 알면 멀티스레드 공부까지 찍먹 끝
    
    </aside>
    
    ---
    
    ---
    
    ### 프로세스
    
    <aside>
    🤸‍♂️
    
    동시에 자바 프로그램을 실행하면 OS ( 운체 ) 에선 메모리에 자리를 잡고 , 
    프로세스를 만듭니다
    프로세스는 운체로부터 JVM이 동작할 공간을 할당합니다
    
    잠깐 …!여기서 꼬일 수 있는데 계층 구조로 설명하자면 
    운영체제 > 프로세스 > JVM 입니다 
    
    </aside>
    
    </aside>